# Tree
  - 정보를 쉽게 검색하기 위해 저장할 때 유용한 자료구조
  - 계층 구조를 추상화한 모델
  - ex) 가계도, 회사 조직

### 트리 용어
```
                              __
  level 0                    |11| (root)
                       ------|__|------ 
                      |                |
                     __                __  
  level 1           | 7|              |15|
                    |__|              |__|
                    /  \              /  \
                   /    \            /    \
                 __       __        __       __ 
  level 2       | 5|     | 9|      |13|     |20|
                |__|     |__|      |__|     |__|
                /  \     /  \      /  \     /  
               |    |   |    |    |    |   |    
              __   __   __   __   __   __   __   
  level 3    | 3| | 6| | 8| |10| |12| |14| |18|
             |__| |__| |__| |__| |__| |__| |__|


하나의 원소를 노드라고 부른다. 그 중에 최상위 노드는 루트(root)라고 부른다
내부노드: 1개 이상의 자식을 가진 노드 (ex, 7, 5, 9, 15, 13 ,20)
외부노드(== 리프): 자식이 없는 노드(3, 6, 8, 10, 12, 14, 18 ,25)
조상과 후손이 있는데, 조상은 상위 계층의 노드. 후손은 하위 계층의 노드
서브트리: 노드와 후손으로 구성된 트리 (ex, 13, 12, 14는 서브트리. 20, 18도 서브트리이다)
노드의 깊이(depth): 노드 6의 깊이는 3개의 조상(11, 7, 5)을 갖고 있으므로 3이다
트리의 높이(height): 깊이의 최대치. 위의 트리에서는 (레벨이 3까지 있으므로)3이다.
```

  - 이진트리(binary tree)
    - 최대 2개의 자식노드를 갖는다
    - 노드의 삽입, 조회, 삭제를 효과적으로 수행가능

  - 이진 탐색 트리(binary search tree)
    - 좌측 자식 노드에는 더 작은 값, 우측 자식 노드에는 더 큰 값 (위의 트리가 이진 탐색 트리)

### 이진 탐색 트리의 내부적 동작
```
내부적으로 동작하는 것을 보면 이중 연결리스트가 생각난다.

                             ___________
        (left)  ------------|-- | 11| --|-----------  (right)
               |            |___|___|___|           |
               V                (key)               V 
          ___________                          ___________     
       --|-- |  7| --|--                    --|-- | 15| --|--
      |  |___|___|___|  |                  |  |___|___|___|  |
      V                 V                  V                 V
 ___________       ___________        ___________       ___________
|   |  5|   |     |   |  9|   |      |   | 13|   |     |   | 20|   |
|___|___|___|     |___|___|___|      |___|___|___|     |___|___|___|
null     null     null     null      null     null     null     null

노드 간에 연결은 포인터로 나타낸다 

코드를 보면 이해가 더 쉽다

this.insert = funtion(key){
	ver newNode = new Node(key);

	if(root === null){ // 트리가 비어있다면
		root = newNode; // insert한 값을 root로 설정
	}else{
		insertNode(root, newNode);
	}
};

var insertNode = function(node, newNode){
	if(newNode.key < node.key){ // 입력받은 node의 key가 기존의 node의 key보다 작으면
		if(node.left === null){ // 그 node의 왼쪽 후손이 비어있으면
			node.left = newNode; // 왼쪽에 삽입
		}else{ // 후손이 비어있지 않다면 다시 그 후손과 입력받은 key를 정확한 위치를 찾을 때까지 비교 
 			insertNode(node.left, newNode);
		}
    } else{ // 입력받은 node의 key가 기존의 node.key보다 크면
    	if(node.right === null){
    		node.right = newNode;
    	} else{
    		insertNode(node.right, newNode);
    	}
    }
}
```