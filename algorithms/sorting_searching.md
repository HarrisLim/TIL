# 정렬과 검색 

## 정렬 알고리즘
#### 버블 정렬 (Bubble sort)
  - 단순한 로직, 실행시간은 최악
  - 인접한 두 원소를 모두 비교하고 그 결과에 따라 두 원소의 위치를 서로 바꾼다
  - 얼마나 비효율적인지 밑의 그림을 보면 알 수 있다.
  - *이미 정렬된 숫자들은 비교하지 않는 **개선된 버블정렬**도 있다
```
                 -------------------
                | 5 | 4 | 3 | 2 | 1 |
                 -------------------
  (1)                                 (2)
  5 4 3 2 1 // [5 > 4], 교환             4 3 2 1 5 //[4 > 3], 교환
  4 5 3 2 1 // [5 > 3], 교환             3 4 2 1 5 //[4 > 2], 교환
  4 3 5 2 1 // [5 > 2], 교환             3 2 4 1 5 //[4 > 1], 교환
  4 3 2 5 1 // [5 > 1], 교환             3 2 1 4 5 //[4 < 5], 교환하지 않음
  4 3 2 1 5
  
  (3)                                  (4)
  3 2 1 4 5 // [3 > 2], 교환              2 1 3 4 5 // [2 > 1], 교환
  2 3 1 4 5 // [3 > 1], 교환              1 2 3 4 5 // [2 < 3], 교환하지 않음
  2 1 3 4 5 // [3 < 4], 교환하지 않음       1 2 3 4 5 // [3 < 4], 교환하지 않음
  2 1 3 4 5 // [4 < 5], 교환하지 않음       1 2 3 4 5 // [4 < 5], 교환하지 않음

  (5)
  1 2 3 4 5 // [1 < 2], 교환하지 않음
  1 2 3 4 5 // [2 < 3], 교환하지 않음
  1 2 3 4 5 // [3 < 4], 교환하지 않음
  1 2 3 4 5 // [4 < 5], 교환하지 않음
  1 2 3 4 5 (결과)
```

#### 선택 정렬 (Selection sort)
  - 최소값을 찾아 맨 앞으로 보내고, 그 다음으로 작은 값을 찾아 뒤에 놓는 방식
```
     -------------------
    | 5 | 4 | 3 | 2 | 1 |
     -------------------
     				*이 있는 범위만 체크한다. 최소값을 맨 앞으로 보내기 때문에, 한 칸씩 뒤로 줄어든다
  * * * * *
  5 4 3 2 1 // 1이 최소 [5, 1 교환]

    * * * *
  1 4 3 2 5 // 2가 최소 [4, 2 교환]

      * * *  
  1 2 3 4 5 // 3이 최소 [3 == 3 제자리] 

        * *
  1 2 3 4 5 // 4가 최소 [4 == 4 제자리]
  1 2 3 4 5 (결과)
```

#### 삽입 정렬 (Insertion sort)
  - 한 번에 한 원소씩 정렬된 배열을 만든다
  - 첫 번째 원소는 정렬이 끝났다고 가정하고  
    두 번째 원소와 비교해 첫 번째 원소보다 더 작다면 첫 번째 원소의 앞으로 옮긴다  
    그렇게, 처음 두 원소의 정렬이 끝나면 다음엔 세 번째 원소와의 비교를 계속 한다  
```
     -------------------
    | 3 | 5 | 1 | 4 | 2 |
     -------------------

  3 5 1 4 2 // 5를 선택 (3이 5보다 작으니까 3은 정렬이 됐다고 판단)
  3 5 1 4 2 // [3 < 5]이므로 5는 변동 없음

  3 5 1 4 2 // 1을 선택
  3 ? 5 4 2 // [5 > 1]이므로 이동
  ? 3 5 4 2 // [3 > 1]이므로 이동
  1 3 5 4 2 // 인덱스 0위치에 1을 삽입

  1 3 5 4 2 // 4를 선택
  1 3 ? 5 2 // [5 > 4]이므로 이동
  1 3 4 5 2 // [3 < 4]이므로 4를 삽입

  1 3 4 5 2 // 2를 선택
  1 3 4 ? 5 // [5 > 2]이므로 이동
  1 3 ? 4 5 // [4 > 2]이므로 이동
  1 ? 3 4 5 // [3 > 2]이므로 이동
  1 2 3 4 5 // [1 < 2]이므로 2를 삽입
  1 2 3 4 5 (결과)
```

#### 병합 정렬 (Merge sort)
  - 성능이 뛰어나다 // O(n log n)
  - 핵심은 분할과 정복이다
  - 정렬할 배열을 원소가 하나뿐인 배열 단위로 나뉠 때까지 분할하고,  
    이렇게 분할된 배열을 점점 더 큰 배열로 병합하면서 정렬한다
```
    -------------------------------
   | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 
    -------------------------------
          (좌)               (우)
        8 7 6 5            4 3 2 1                
      (좌)     (우)       (좌)     (우)            분할
      8 7      6 5       4 3      2 1
    (좌) (우) (좌) (우)  (좌) (우) (좌) (우)    --------------
     8   7    6   5     4   3    2   1 
      (좌)     (우)       (좌)     (우)            병합
      7 8     5 6        3 4     1 2             
          (좌)               (우)
        5 6 7 8            1 2 3 4
    -------------------------------
   | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 
    -------------------------------       
```

#### 퀵 정렬 (Quick sort)
  - 성능이 뛰어나다 // O(n log n)
  - 병합 정렬과 마찬가지로 분할/정복 방식으로 접근 (but, 병합 정렬처럼 원소를 하나까지 잘게 나누지는 않는다)
  - 파티션 (Partition)
    - 중간 지점에 위치한 원소보다 작은 원소는 좌측에, 큰 원소는 우측에 나열
```
여기 그림 정리하자
```

## 검색 알고리즘
#### 순차 검색 (Sequential search)
  - 원하는 원소를 찾을 때까지 자료구조 전체를 뒤져보는, 가장 비효율적인 알고리즘
```
  만약 3을 찾는다면,
     -------------------
    | 5 | 4 | 3 | 2 | 1 |
     -------------------

     5 4 3 2 1 // [5 == 3] false니까 다음 원소 검색
     5 4 3 2 1 // [4 == 3] false니까 다음 원소 검색
     5 4 3 2 1 // [3 == 3] true !!
```

#### 이진 검색 (Binary search)
  - 범위를 좁혀가면서 검색한다
  - 정렬을 먼저하고 검색한다
```
    * 중간원소(M)보다 검색하고자 하는 원소가 더 작다면, L이 M+1인덱스를 가리키게 한다
    * 중간원소(M)이 검색하고자 하는 원소보다 크다면 H가 M-1를 가리키게 한다

  만약 2를 찾는다면,
    -------------------------------
   | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |  
    -------------------------------

    1 2 3 4 5 6 7 8 // 검색 전, 정렬한다 !
    1 2 3 4 5 6 7 8 // 중간에 있는 원소를 찾는다. 여기서는 4이다.
    L     M       H // L: low, M: mid, H: high

    1 2 3 4 5 6 7 8 // [1 < 2] L을 멈춘다, [8 > 2]니까
    L     M       H // M이 검색하고자 하는 원소(2)보다 크니까 H가 M-1을 가리키게 한다

    1 2 3 4 5 6 7 8 // M은 L과 H사이의 중간으로 다시 설정해준다
    L M H           // [2 < 2] 아니고, [2 > 2]가 아니니까, [2 == 2]가 성립한다.

```